・一時データ: データの挿入中やクエリ実行時には、SQLiteは一時的に必要なデータをメモリ上に保持します。
例えば、レコードをバッチで挿入する際、SQLiteは一時的にそのデータをメモリに保持し、
トランザクションがコミットされるまでディスクに書き込まれません。
また、大量のデータを一度に挿入する場合、
インデックスを伴う場合はインデックスの再構築用に大量の一時メモリが消費されます。

・sqliteのリソース使用
. メモリ使用量
ページキャッシュ: SQLiteはデータベースを読み書きする際、データをページ単位でキャッシュします。レコードが多くなるほど、ページキャッシュのメモリ使用量も増加します。デフォルトでは、SQLiteは約2,000ページ（約2MB）をキャッシュしますが、大量のデータではこのキャッシュが膨大になり、メモリ消費が増えます。
一時テーブルや一時データ: 大量のレコードを一度に挿入する際、一時データが発生します。これもメモリ使用量に影響を与える要因です。
2. ディスクI/O
トランザクションのコミット: SQLiteでは、挿入ごとにトランザクションをコミットすると、ディスクI/Oが頻繁に発生します。これはパフォーマンスの低下につながる原因の一つで、特にハードディスクドライブ（HDD）では顕著です。
ジャーナリングモード: デフォルトではSQLiteは「WAL（Write-Ahead Logging）」を使用してデータの一貫性を保つため、ディスクへの書き込みがさらに増加します。これはリソース消費を増加させ、処理時間が延びる要因になります。
3. CPU使用率
インデックスの再構築: 大量のデータを挿入する際、特にインデックスが設定されている場合、各挿入でインデックスが再構築されます。これによりCPU使用率が上昇します。1億件ものデータがあると、インデックスのオーバーヘッドがかなりの負担となります。
4. プロセスがkillされる理由
メモリ不足: 大量のデータを扱う場合、システムの物理メモリが不足し、スワップが発生し、最終的にプロセスがkillされることがあります。特にページキャッシュや一時データのためにメモリを消費しすぎると、システムが他のプロセスに影響を与えないようにプロセスを終了させることがあります（Out Of Memory、OOM）。
ディスクスペース不足: ディスク容量が不足する場合もプロセスが終了することがあります。SQLiteは大量のデータを挿入する際にジャーナルファイルや一時ファイルを作成するため、ディスクスペースが不足するとエラーが発生することがあります。
5. リソース消費の最適化方法
トランザクションを利用する: 大量のデータを挿入する際、トランザクションを明示的に管理し、複数のレコードを一括でコミットすることでディスクI/Oの頻度を減らします。例えば、1万件ごとにトランザクションをコミットすることで、パフォーマンスが大幅に向上します。
インデックスの無効化: 挿入前にインデックスを一時的に無効にし、挿入後に再構築することで、インデックスのオーバーヘッドを回避できます。
PRAGMA設定: SQLiteのPRAGMAコマンドを使用して、synchronousモードを「OFF」にしたり、journal_modeを「MEMORY」や「OFF」に設定することで、I/O負荷を軽減できます。ただし、これによりデータの整合性や安全性が犠牲になる可能性があるため、注意が必要です。