1. generation=0の場合動かない
2. 並列処理の追加にあったってgeneration=偶数の場合リグレッション発生
3. 同時に何プロセス起動しているかデバック出力する
   -> Pool(processes=N)Nをコア数以上にした場合のCPUの奪い合いによる遅延をo1を元に整理しておく
4. 1プロセスあたりの処理時間が短いためオーバーヘッドの遅延が目立っている
   chunk_sizeに指定している値をパターン数に応じて適切に指定する
5. チェックポイントを作成する(処理が長すぎると最初からやるのがめんどくさい)
6. 事前計算できる箇所はしておく
7. 省ける箇所を除いて計算する
・「黒または白石が置かれるマスの選択パターン」はstone_num_patternで共通のため
  stone_num_patternごとに算出するのは無駄
  ※ ただ、対象性を利用して除外する際にstone_num_patternごとに限定してできるため
     メモリ効率を考える必要がある
・除外方法の1つに「孤立石かどうか」があるが「黒または白石が置かれるマスの選択パターン」ですでに除外できる。
・[メモリ効率]メモリを圧迫している原因としてsetで状態を持って追加時に重複がある場合を除いているが
  状態(=board)はタプルで持っているが例えば黒石のある範囲内でファイルを作成してそこに持つことで
  1度にメモリ上に展開しているものは省くことができる