[]世代=8で方法1ではOOMは発生しないいのに方法2では発生した原因を調べる
[] generation=0の場合動かない
[] 並列処理の追加にあったってgeneration=偶数の場合リグレッション発生
[] 同時に何プロセス起動しているかデバック出力する
   -> Pool(processes=N)Nをコア数以上にした場合のCPUの奪い合いによる遅延をo1を元に整理しておく
[] 1プロセスあたりの処理時間が短いためオーバーヘッドの遅延が目立っている
   chunk_sizeに指定している値をパターン数に応じて適切に指定する
[] チェックポイントを作成する(処理が長すぎると最初からやるのがめんどくさい)
[] 事前計算できる箇所はしておく
[] 省ける箇所を除いて計算する
[]「黒または白石が置かれるマスの選択パターン」はstone_num_patternで共通のため
  stone_num_patternごとに算出するのは無駄
  ※ ただ、対象性を利用して除外する際にstone_num_patternごとに限定してできるため
     メモリ効率を考える必要がある
[]除外方法の1つに「孤立石かどうか」があるが「黒または白石が置かれるマスの選択パターン」ですでに除外できる。
  [・]実装
  []除外ステップに応じでどれくらい除外されたかをCSVに出力する
[][メモリ効率]メモリを圧迫している原因としてsetで状態を持って追加時に重複がある場合を除いているが
  状態(=board)はタプルで持っているが例えば黒石のある範囲内でファイルを作成してそこに持つことで
  1度にメモリ上に展開しているものは省くことができる
[]rustに移行
[]「黒または白石が置かれるマスの選択パターンは60C(generation)
   メモリ対策で2次元をgeneration個の1次元を60C(generation)個のnumpyで持つ
[]新規フロー作成
  1. 「黒と白のおける場所の組み合わせパターン」をすべて取得
      npyに保存するデータ
        1. マスを1としたtuple
          -> 一旦こちらで採用
        2. ビットボード
  2. 黒と白のそれぞれの石の数 * 1で求めたパターンごとに状態を作成
     この際に重複は除外する

・最終的なゲーム進行上可能な状態数
  「雑な推定最大状態数」よりgeneration=40が一番多そう
  1世代最大1ヶ月くらいの計算で終わらせたい。
  1ヶ月=30日=24*30=720h
  pythonの速度はrustの1/100の速度だと仮定すると
  状態数が1/100のgeneration=28を1ヶ月でpythonで算出したい。
  1日の計算でgeneration=24までは可能にしたい



-------方法の違いによる世代ごとのパターン計算完了度-------
・方法1
  1,2,3,4,5,6,7,8

・方法2 
  1,2,3,4,5,6,7

  8: workerごとのバッチが1500万だとOOMが発生する
     解決案: バッチごとではなく1津づつ処理する。1workerごとのメモリ最大使用量を指定してそれを超えた場合npyファイルを保存する。
  
----------------------------------------------------------

