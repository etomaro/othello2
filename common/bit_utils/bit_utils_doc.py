"""
ビット操作に関する実装型のドキュメント

---仕様系---
1.1 指定桁以下のビットをすべて1、指定桁より上をすべて0
1.2. 無限長でのビット反転(~x)
1.3. 固定長でのビット反転(~x & mask)
1.4. -x

---基本演算系---
2.1 &
2.2 |
2.3 xor 
2.4 左シフト
2.5 右シフト
2.6 1の数をカウント

---文字列出力---
3.1 0bをつけずに出力
3.2 固定長のbitとして0bをつけずに出力

---小技---
4.1 奇数・偶数判定
4.2 最も下位の1ビットを取り出す(x & -x)

---大技---
5.1 固定長かつで1の数が固定のすべてのパターンを取得する(gosper's hack)

"""

def _get_1_under_the_digit(digit: int) -> int:
    """
    1. 指定桁以下のビットをすべて1、指定桁より上をすべて0
    
    ロジック
      最終的な値+1の状態を生成して-1をすることで取得する
    
    ex: digit=3, return=0b0111
    
    args:
      digit: 指定桁
    """
    return 1<<(digit+1) - 1
  
def _get_bit_reverse(value: int) -> int:
    """
    2. 無限長でのビット反転(~x)

    まずpythonでの数値は無限長ビット扱いになる。
    例えば10進数で3は2進数では0b010や0b10でpythonだとかけるが
    データ上だとどちらも000....00010

    ビット反転を行うと
    111...11101

    ビット反転したものをpython上で2進数で出力すると
    print(bin(~x)) -> "-0b100"と出力される
    ※ 混乱を招く原因だが負の値をpythonで2進数文字出力をすると"-" + "絶対値"の形で出力される
    ※ pythonは2の補数(~x+1)を用いているため「0b111...11101」は「-4」となる。「4」は「0b100」のため「-0b100」と出力されている

    ※ 2の補数の性質上、最上位ビットが1の場合は負の値    
    """
    return ~value

def _get_bit_reverse_limited(value: int, mask_ndigit) -> int:
    """
    3. 固定長でのビット反転(~x & mask)

    数値としてではなくビットとして使用する際に使用する考え方

    0b1101 -> 0b0010としたい場合に使用する
    正確には「0b1101」は「0b000...1101」,「0b0010」は「0b000...0010」のため~
    xとしても「0b111...1101」となるため「0b0010」とはならない
    
    ビット反転したものに使用するビット幅のすべてが1のマスクと&を取ることで実現する
    ex: 0b1101 -> ビット反転 -> 0b111..1101 -> 0b1111のマスクと& -> 0b1101

    args:
      value: 値
      mask_ndigit: ビット反転する最大桁数(ex: mask_ndigit=4の場合マスクは0b1111)
    """
    mask = 2**mask_ndigit -1  # mask_ndigitが2の場合0b100 - 1 -> 0b11
    return mask & ~value

def _get_negative_value(value: int) -> int:
    """
    2. -xとは
    
    コンピューターで負の値を表現する方法を考える
    どの方法だとしてもnbit固定長の場合表現できる絶対値の個数は2^(n-1)個
    
    1. 絶対値表現
        n固定値で数値を扱う場合、n番目を+or-を扱う。
          n       | n-1  n-2 1  |
        0 or 1    | 数値の絶対値 |
         
    2. 1の補数
        ※ なぜ1の補数というか
        ※ 補数とは: n進数の数に加算すると1桁上がる数の最小値。2進数の場合,最低でも+2をすると1桁上がるため2進数の補数は2で「2の補数」という
        
        「1の補数方式」は、“全ビットが1の状態”(例えば8ビットなら 1111 1111-255)を基準にして「その値との差をとる」ことによって負数を表現する。
        -> ビット反転した形になる
        
        0101 0101の場合
        1010 1010が負の値と表現する。最上位のビットは正負の判定になる
        
        デメリット: 0000 0000と1111 1111がともにゼロになる(0と-0が混在する)
        
    3. 2の補数
        ビット反転した後1を加算する方法で負の値を表現する(=1の補数に1を加算したもの)
        common/bit_utils/2の補数.xlsxに記載
      
    args:
      value: 値
    """
    pass 