"""
ビット操作に関する実装型のドキュメント

1. 指定桁以下のビットをすべて1、指定桁より上をすべて0
2. ビット反転
3. -xとは
"""

def _get_1_under_the_digit(digit: int) -> int:
    """
    1. 指定桁以下のビットをすべて1、指定桁より上をすべて0
    
    ロジック
      最終的な値+1の状態を生成して-1をすることで取得する
    
    ex: digit=3, return=0b0111
    
    args:
      digit: 指定桁
    """
    return 1<<(digit+1) - 1
  
def _get_bin_reverse(value: int) -> int:
    """
    2. ビット反転
    
    ロジック 
      n桁固定長の値
    
    """

def _get_negative_value(value: int) -> int:
    """
    2. -xとは
    
    コンピューターで負の値を表現する方法を考える
    どの方法だとしてもnbit固定長の場合表現できる絶対値の個数は2^(n-1)個
    
    1. 絶対値表現
        n固定値で数値を扱う場合、n番目を+or-を扱う。
          n       | n-1  n-2 1  |
        0 or 1    | 数値の絶対値 |
         
    2. 1の補数
        ※ なぜ1の補数というか
        ※ 補数とは: n進数の数に加算すると1桁上がる数の最小値。2進数の場合,最低でも+2をすると1桁上がるため2進数の補数は2で「2の補数」という
        
        「1の補数方式」は、“全ビットが1の状態”(例えば8ビットなら 1111 1111-255)を基準にして「その値との差をとる」ことによって負数を表現する。
        -> ビット反転した形になる
        
        0101 0101の場合
        1010 1010が負の値と表現する。最上位のビットは正負の判定になる
        
        デメリット: 0000 0000と1111 1111がともにゼロになる(0と-0が混在する)
        
    3. 2の補数
        ビット反転した後1を加算する方法で負の値を表現する(=1の補数に1を加算したもの)
        common/bit_utils/2の補数.xlsxに記載
      
    args:
      value: 値
    """
    pass 